- # 数组
- 数组 Array #card
	- 1. 线性表数据结构
	  2. 用一组连续的内存空间，来存储一组具有相同类型的数据
- 线性表 Linear List #card
- 随机访问 #card
- 容器类型能否代替数组 #card
	- Java ArrayList
	- 优点：封装数组方法、支持动态扩容
	- 缺点：无法存储基本类型性能场景有损耗，性能场景大多数封装方法应该尽量避免使用
	- JavaScript Array 底层实现不是数组，而是哈希表
- 为什么大多数编程语言中，数组要从 0 开始编号 #card
	- 1. 下标代表偏移量，从0开始符合逻辑
	- 2. C 语言的选择，后续语言为了减少学习成本，延续了这个习惯。
	- Matlab 数组索引从1开始
-
- # 链表
- 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。
- 除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。
- ### 哨兵
- 如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫**带头链表**。相反，没有哨兵结点的链表就叫作**不带头链表**。
- ![image.png](../assets/image_1667460652926_0.png)
- ### 注意边界条件的处理
	- 如果链表为空时，代码是否能正常工作？
	- 如果链表只包含一个结点时，代码是否能正常工作？
	- 如果链表只包含两个结点时，代码是否能正常工作？
	- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
- ### 熟能生巧 #card
	- 单链表反转
	- 链表中环的检测
	- 两个有序的链表合并
	- 删除链表倒数第 n 个结点
	- 求链表的中间结点
- # 栈
- **栈是一种“操作受限”的线性表**，只允许在一端插入和删除数据。
- 为什么不用数组或链表替代栈？#card
	- 事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，**特定的数据结构是对特定场景的抽象**，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。
	- **当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构**。
	- 实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作**顺序栈**，用链表实现的栈，我们叫作**链式栈**。
- # 队列
- 跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作**顺序队列**，用链表实现的队列叫作**链式队列**。
- 循环队列
- ![image.png](../assets/image_1667464409475_0.png){:height 308, :width 518}
- 阻塞队列
- 可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”。
- 配平效率
- ![image.png](../assets/image_1667464669187_0.png)
- 并发队列
- 基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue）
- 基于数组实现的有界队列（bounded queue）
-
- **实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。**
-
- # 递归
- 什么样的问题可以用递归来解决？#card
	- 1. **一个问题的解可以分解为几个子问题的解**
	- 2. **这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**
	- 3. **存在递归终止条件**
	- 方法论：**写出递推公式，找到终止条件**
-
- **编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤**。
-
- 避免堆栈溢出
- 设定调用入栈最大深度，但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。
-
- 避免重复计算
- ![image.png](../assets/image_1667469601805_0.png)
- 在诸如散列表中存储已求解过的值，避免重复计算
- **将递归代码改写为非递归代码**
-
- # 二分
- 我这里就再深入地讲讲 O(logn) 这种**对数时间复杂度**。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效。
- 因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。比如n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。
- 我们前面讲过，用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高。
- ### 局限性
- **首先，二分查找依赖的是顺序表结构，简单点说就是数组。**
- **其次，二分查找针对的是有序数据。**
- **再次，数据量太小不适合二分查找。**
- **最后，数据量太大也不适合二分查找。**
- 二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。
- 注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。
- 虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，我们后面会讲，不管是散列表还是二叉树，都会需要比较多的额外的内存空间。如果用散列表或者二叉树来存储这 1000 万的数据，用 100MB 的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。
-
- # 双指针
- 双指针缩进解法是一种剪枝的技法。任何尝试使用此解法必须证明被减去的树枝都是无效解。对于简单的场景大多数人直接在脑中完成了这个步骤，复杂的则需要借助数学来证明。若无法证明则无法使用双指针缩进的解法（因为心里没底）。
-
-
-
- # 二叉树
- 树的节点高度、深度、层数？#card
	- ![下载 (1).jpeg](../assets/下载_(1)_1668479350453_0.jpeg)
	- ![下载 (2).jpeg](../assets/下载_(2)_1668479375831_0.jpeg)
- 满二叉树和完全二叉树？#card
	- 满二叉树：
		- 1. 叶子节点全都在最底层
		  2. 除了叶子节点之外，每个节点都有左右两个子节点
		- ![image.png](../assets/image_1668479592315_0.png){:height 148, :width 203}
	- 完全二叉树：
		- 1. 叶子节点都在最底下两层
		  2. 最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大
		- ![image.png](../assets/image_1668479622975_0.png){:height 171, :width 176}
		-
	-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-