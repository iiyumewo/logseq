- ## 执行效率
- **1. 最好情况、最坏情况、平均情况时间复杂度**
- 排序算法在不同数据下的性能表现。
- 最好、最坏情况下的时间复杂度很容易分析，平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。
- 对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，执行的时间肯定是不同的。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。还有一种思路，通过 [[数据的有序度和逆序度]] 来进行分析。
- 以折中的有序度 `n*(n-1)/4` 作为平均值来衡量一个算法的平均时间复杂度。这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用。
- **2. 时间复杂度的系数、常数 、低阶**
- 在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来
- **3. 比较次数和交换（或移动）次数**
- ##
- ## 排序算法的内存消耗
- 即空间复杂度，引入排序算法特殊概念**原地排序**（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。
- ##
- ## 排序算法的稳定性
- **稳定性**。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
-
-
- [[冒泡排序 Bubble Sort]]
- [[插入排序 Insertion Sort]]
- [[选择排序 Selection Sort]]
- [[归并排序 Merge Sort]]
- [[快速排序 Quick Sort]]
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-